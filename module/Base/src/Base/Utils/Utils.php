<?phpnamespace Base\Utils;use \Exception;class Utils {    /**     Please send me the needles as an array, but you also can send a String     If you need to validate one needle only     */    public static function arrayKeyExists( $needles, $array, $throwEx = true ) {        $return = false;        // check if it's even an array        if ( ! is_array( $array ) ) return false;        if ( ! is_array( $needles ) ) $needles = array( $needles );        foreach ( $needles as $needle ) {            // Validate key exists            if ( array_key_exists( $needle, $array ) ) {                $return = true;                continue;            }            // key isn't in this array, go deeper            foreach ( $array as $key => $val ) {                if ( ! is_array( $val ) ) {                    if ( $key == $needle ) {                        $return = true;                        continue 2;                    }                } elseif ( Utils::arrayKeyExists( $needle, $val, $throwEx ) ) {                    $return = true;                    continue 2;                }            }        }        if ( !$return && $throwEx ) {            throw new Exception( 'Please check the array, This key does not exist: ' . $needle );        }        return $return;    }    public static function arrayValueExists( $needle, $haystack ) {        return in_array( strtolower( $needle ), array_map( 'strtolower', $haystack ) );    }    /**     Please send me: array( 'uri'=> '', 'method'=>''[, 'curloptions'=> array( ... ) ])     I will throw an Exception if something goes wrong so no need to validate     But you can decide whether you wnat me to do it or not     */    public static function sendRequest( $arrayParms, $throwEx = true ) {        Utils::arrayKeyExists( array( 'url', 'method' ), $arrayParms );        $client = new \Zend\Http\Client( $arrayParms[ 'url' ] );        $client->setMethod( $arrayParms[ 'method' ] );        switch ( $arrayParms[ 'method' ] ) {        case POST:            Utils::arrayKeyExists( 'payload', $arrayParms );            $client->setParameterPost( $arrayParms[ 'payload' ] );            break;        case GET:            Utils::arrayKeyExists( 'payload', $arrayParms );            $client->setParameterGet( $arrayParms[ 'payload' ] );            break;        }        $adapter = new \Zend\Http\Client\Adapter\Curl( );        $curloptions = array(            CURLOPT_POST => 1,            CURLOPT_HTTPAUTH => CURLAUTH_BASIC,            CURLOPT_RETURNTRANSFER => 1,            CURLOPT_SSL_VERIFYPEER => FALSE,            CURLOPT_SSL_VERIFYHOST => FALSE,        );        if ( array_key_exists( 'curloptions', $arrayParms ) ) {            $curloptions = array_merge( $curloptions, $arrayParms[ 'curloptions' ] );        }        $adapter->setOptions( array(                'curloptions' => $curloptions            ));        $client->setAdapter( $adapter );        $response = $client->send( );        if ( $response->isSuccess( ) ) {            // the POST was successful            $response = json_decode( $response->getBody( ), true );        } elseif ( $throwEx ) {            throw new Exception( 'I could not do the Request: ' . $arrayParms );        }        return $response;    }    /**     * Retrieves the best guess of the client's actual IP address.     * Takes into account numerous HTTP proxy headers due to variations     * in how different ISPs handle IP addresses in headers between hops.     */    public static function getRemoteIpAddress( ) {        // Check for shared internet/ISP IP        if (!empty($_SERVER['HTTP_CLIENT_IP']) && Utils::validate_ip($_SERVER['HTTP_CLIENT_IP']))            return $_SERVER['HTTP_CLIENT_IP'];        // Check for IPs passing through proxies        if (!empty($_SERVER['HTTP_X_FORWARDED_FOR'])) {            // Check if multiple IP addresses exist in var            $iplist = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);            foreach ($iplist as $ip) {                if (Utils::validate_ip($ip))                    return $ip;            }        }        if (!empty($_SERVER['HTTP_X_FORWARDED']) && Utils::validate_ip($_SERVER['HTTP_X_FORWARDED']))            return $_SERVER['HTTP_X_FORWARDED'];        if (!empty($_SERVER['HTTP_X_CLUSTER_CLIENT_IP']) && Utils::validate_ip($_SERVER['HTTP_X_CLUSTER_CLIENT_IP']))            return $_SERVER['HTTP_X_CLUSTER_CLIENT_IP'];        if (!empty($_SERVER['HTTP_FORWARDED_FOR']) && Utils::validate_ip($_SERVER['HTTP_FORWARDED_FOR']))            return $_SERVER['HTTP_FORWARDED_FOR'];        if (!empty($_SERVER['HTTP_FORWARDED']) && Utils::validate_ip($_SERVER['HTTP_FORWARDED']))            return $_SERVER['HTTP_FORWARDED'];        // Return unreliable IP address since all else failed        return $_SERVER['REMOTE_ADDR'];    }    /**     * Ensures an IP address is both a valid IP address and does not fall within     * a private network range.     *     * @access public     * @param string $ip     */    public static function validate_ip( $ip ) {        if ( filter_var( $ip, FILTER_VALIDATE_IP,                FILTER_FLAG_IPV4 |                FILTER_FLAG_IPV6 |                FILTER_FLAG_NO_PRIV_RANGE |                FILTER_FLAG_NO_RES_RANGE ) === false )            return false;        self::$ip = $ip;        return true;    }    public static function dateTimeNow( $format = 'Y-m-d H:i:s' ) {        $dt = new \DateTime( );        $result = $dt->format( $format );        return $result;    }}