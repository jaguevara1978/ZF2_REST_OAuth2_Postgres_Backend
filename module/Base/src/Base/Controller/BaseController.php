<?phpnamespace Base\Controller;use \Exception;use \stdClass;use Zend\Mvc\Controller\AbstractRestfulController;use Zend\View\Model\JsonModel;use OAuth2\Server as OAuth2Server;use OAuth2\Request as OAuth2Request;use Base\Exception\CommonException;class BaseController extends AbstractRestfulController {    protected $table;    protected $translator;    protected $entity;    protected $moduleName;    protected $model;    protected $form;    protected $childNamespace;    protected $oauth2Server;    protected $dbname;    protected $validateOAuth = true;    protected $validatePayload = true;    protected $config;    protected $connection;        public function getConnection( ) {        if ( ! $this->connection ) {            $this->connection = $this->getAdapter( $this->getDBName( ) )->getDriver( )->getConnection( );        }        return $this->connection;    }    public function getConfig( ) {        if ( ! $this->config ) {            $this->config = $this->getServiceLocator( )->get( 'config' );        }        return $this->config;    }    public function setValidatePayload( $boolean ) {        $this->validatePayload = $boolean;    }    public function setValidateOAuth( $boolean ) {        $this->validateOAuth = $boolean;    }    public function setEntity( $string ) {        $this->entity = ucwords( $string );    }    public function setChildNameSpace( $string ) {        $this->childNamespace = $string;    }    private function getChildNamespace( ) {        if ( !$this->childNamespace ) {            throw new CommonException (                array(                    'messageId'=>'globals.errors.undefined_namespace',                    'parms'=>array( 'entity'=>$this->entity )                )            );        }        return $this->childNamespace;    }    public function getTranslator( ) {        if ( !$this->translator ) {            $this->translator = $this->getServiceLocator( )->get( 'translator' );        }        return $this->translator;    }    public function setTranslator( $translator ) {        $this->translator = $translator;    }        private function getModuleName( ) {        if ( !$this->moduleName ) {            $arr = explode( '\\', $this->getChildNamespace( ) );            $this->moduleName = reset( $arr );        }        return $this->moduleName;    }    public function setModuleName( $string ) {        $arr = explode( '\\', $string );        $this->moduleName = reset( $arr );    }    private function getFormName( ) {        return $this->getModuleName( ).'\\Form\\'.$this->entity.'Form';    }    public function getForm( ) {        if ( !$this->form ) {            $formName = $this->getFormName ( );            $this->form = new $formName( );        }        return $this->form;    }    private function getModelName( ) {        return $this->getModuleName( ).'\\Model\\'.$this->entity;    }    public function getModel( ) {        if ( !$this->model ) {            $modelName = $this->getModelName ( );            $this->model = new $modelName( );        }        return $this->model;    }    private function getTableName( ) {        return $this->getModuleName().'\\Model\\'.$this->entity.'Table';    }    public function getAdapter ( $name = 'Zend\Db\Adapter\Adapter' ) {                return $this->getServiceLocator( )->get( $name );    }    public function setDBName( $string ) {        $this->dbname = $string;    }    public function getDBName( ) {        if ( ! $this->dbname ) {               $this->dbname = strtolower( $this->getModuleName( ) );        }        return $this->dbname;    }    public function getTable( ) {        if ( !$this->table ) {            $tableName = $this->getTableName( );            if ( !class_exists ( $tableName ) ) {                throw new CommonException (                    array(                        'messageId'=>'globals.errors.undefined_class',                        'parms'=>array( 'object'=>$tableName )                    )                );            }            $this->table = new $tableName( $this->getAdapter ( $this->getDBName( ) ) );        }        return $this->table;    }    /**        I check the Id to see if it looks more like a query, and in that case,        I will return the corresponding array with the query fields    */    private function getQuery( $id ) {        if ( is_object( $id ) ) return $id;        if ( is_array( $id ) ) return $id;        if ( strpos( $id, QUERY_STRING_ID ) === false ) return $id;        $queryString = str_replace( QUERY_STRING_ID, '', $id );        parse_str( $queryString, $query );        return $query;    }    /* ************************** // !CRUD **************************** */    public function options( ) {        try {            //$this->validateOAuth2( );            return $this->response( );        } catch ( Exception $e ) {            return $this->response( $e );        }    }    /**        Just remember that, If you want to send me an array with query options        Please use the keys.        Ex.         array(            QUERY_STRING_WHERE => <fieldName>=<value> // This is the where query            QUERY_STRING_ORDERBY => <fieldName>=asc|desc // In case you want to sort            ...        );    */    public function get( $id ) {        try {            $this->validateOAuth2( );            $id = $this->getQuery( $id );            $result = $this->getTable( )->get ( $id );             return $this->response( $result );        } catch ( Exception $e ) {            return $this->response( $e );        }    }    public function getList( ) {        try {            $this->validateOAuth2( );            $result = $this->getTable( )->fetchAll( );            return $this->response( $result );         } catch ( Exception $e ) {            return $this->response( $e );        }    }	public function create( $data ) {        try {            // Working with transaction            $connection = $this->getAdapter( $this->getDBName( ) )->getDriver()->getConnection();            $connection->beginTransaction();            $this->validateOAuth2( );            $this->validatePayload( $data );            // First I try to insert a new record on Contact            $id = $this->getTable( )->insertRecord( $data );            // Everything OK so far, so commit !            $connection->commit( );            return $this->response( $data );        } catch ( Exception $e ) {            // Rollback any saved stuff            $connection->rollback();            return $this->response( $e );        }    }        public function update( $id, $data ) {        try {            $this->validateOAuth2( );            $this->validatePayload( $data, $id );            $result = $this->getTable( )->updateRecord( $id, $data );            return $this->response( $result );        } catch ( Exception $e ) {            return $this->response( $e );        }    }        public function delete( $id ) {        $this->validateOAuth2( );    }    /* ************************** // !END - CRUD **************************** */    /* ************************** // !UTILS *********************** */    /**        This is an Utility method, I don't give a valid response to a request.        Just remember that, If you want to send me an array with query options        Please use the keys.        Ex.         array(            QUERY_STRING_WHERE => <fieldName>=<value> // This is the where query            QUERY_STRING_ORDERBY => <fieldName>=asc|desc // In case you want to sort            ...        );    */    public function query( $query ) {        try {            $this->validateOAuth2( );            $query = $this->getQuery( $query );            $result = $this->getTable( )->query( $query );             // The result is sent as it is            return $result;        } catch ( Exception $e ) {            return $this->response( $e );        }    }    /**    * Validates against the Form and the Model filters    * Throws an Exception with all the messages associated in case    * of something bad happen    */    public function validatePayload( $data, $id = null ) {        $form  = $this->getForm( );        $model = $this->getModel( );        $model->exchangeArray( $data );        if ( ! $this->validatePayload ) return $model;        // If we are trying to do an Update        if ( $id ) {            // I should validate only the keys that are contained on the array            // Otherwise I will throw error messages for the missing values            // And it is ok, as it is only a record Update            $form->setValidationGroup( array_keys( $data ) );        }        $form->setInputFilter( $model->getInputFilter( ) );        $form->setData( $data );        if ( ! $form->isValid( ) ) {            $messages = null;            foreach ( $form->getInputFilter()->getInvalidInput() as $inputKey => $inputInfo ) {                if ( $messages ) $messages .= ' - ';                $labelKey = $form->getElements()[ $inputKey ]->getLabel( );                $labelKey = $this->getTranslator( )->translate( $labelKey );                $messages .= $labelKey . ': ( ';                $inputMessages = null;                foreach ( $inputInfo->getMessages() as $errorMessage ) {                    if ( $inputMessages ) $inputMessages .= ' - ';                    $inputMessages .= $errorMessage;                }                $messages .= $inputMessages.' )';            }            throw new Exception( $messages, 406 );        }        return $model;    }    /**     * Retrieve the OAuth2\Server instance.     *     * If not already created by the composed $serverFactory, that callable     * is invoked with the provided $type as an argument, and the value     * returned.     *     * @return OAuth2Server     * @throws CommonException if the factory does not return an OAuth2Server instance.     */    private function getOauth2Server( ) {        if ( ! $this->oauth2Server instanceof OAuth2Server ) {            // if the ZF\OAuth2\Service\OAuth2Server service returns an            // OAuth2\Server instance, wrap it in a closure.            $oauth2ServerFactory = $this->getServiceLocator( )->get( 'ZF\OAuth2\Service\OAuth2Server' );            if ( $oauth2ServerFactory instanceof OAuth2Server ) {                $oauth2Server = $oauth2ServerFactory;                $oauth2ServerFactory = function ( ) use ( $oauth2Server ) {                    return $oauth2Server;                };            }            $this->oauth2Server = call_user_func( $oauth2ServerFactory, 'access_token' );            if ( ! $this->oauth2Server instanceof OAuth2Server ) {                throw new CommonException(                    array(                        'messageId'=>'globals.errors.undefined_class',                        'parms'=>array(                            'object'=>is_object( $this->oauth2Server )                                ? get_class( $this->oauth2Server )                                : gettype( $this->oauth2Server )                        )                    )                );            }        }        return $this->oauth2Server;    }    /**     * Create an OAuth2 request based on the ZF2 request object     *     * Marshals:     *     * - query string     * - body parameters, via content negotiation     * - "server", specifically the request method and content type     * - raw content     * - headers     *     * This ensures that JSON requests providing credentials for OAuth2     * verification/validation can be processed.     *     * @return OAuth2Request     */    protected function getOAuth2Request() {        $zf2Request = $this->getRequest();        $headers    = $zf2Request->getHeaders();        // Marshal content type, so we can seed it into the $_SERVER array        $contentType = '';        if ($headers->has('Content-Type')) {            $contentType = $headers->get('Content-Type')->getFieldValue( );        }        // Get $_SERVER superglobal        $server = [];        if ($zf2Request instanceof PhpEnvironmentRequest) {            $server = $zf2Request->getServer()->toArray();        } elseif (!empty($_SERVER)) {            $server = $_SERVER;        }        $server['REQUEST_METHOD'] = $zf2Request->getMethod();        // Seed headers with HTTP auth information        $headers = $headers->toArray();        if (isset($server['PHP_AUTH_USER'])) {            $headers['PHP_AUTH_USER'] = $server['PHP_AUTH_USER'];        }        if (isset($server['PHP_AUTH_PW'])) {            $headers['PHP_AUTH_PW'] = $server['PHP_AUTH_PW'];        }        // Ensure the bodyParams are passed as an array        $bodyParams = $this->bodyParams() ?: [];        return new OAuth2Request(            $zf2Request->getQuery()->toArray(),            $bodyParams,            [], // attributes            [], // cookies            [], // files            $server,            $zf2Request->getContent(),            $headers        );    }    /**     * Validates OAuth2     *     * @return OAuth2Server     * @throws CommonException if there is a problem with the validation     */    public function validateOAuth2( ) {        if ( !$this->validateOAuth ) return true;        // No token validation in case the environment is Development        if ( array_key_exists( 'APPLICATION_ENV', $_SERVER ) ) {             if ( $_SERVER[ 'APPLICATION_ENV' ] == ENVIRONMENT_DEVELOPMENT ) {                return true;             }        }        try {            $server = $this->getOAuth2Server( );               // Handle a request for an OAuth2.0 Access Token and            // throw an exception in case validation unsuccessful            if ( ! $server->verifyResourceRequest( $this->getOAuth2Request( ) ) ) {                $response = $server->getResponse();                $parms = $response->getParameters( );                $message = array_key_exists( 'error_description', $parms )                    ? $parms[ 'error_description' ]                    : 'globals.errors.invalid_token';                $errorKey = array_key_exists( 'error', $parms )                    ? $parms[ 'error' ]                    : INVALID_TOKEN;                    throw new CommonException(                    array(                        'messageId' => $message,                        'parms'=> array( ),                        'code' => $response->getStatusCode( ),                        EXCEPTION_ERRORKEY => $errorKey,                    )                );            }                return true;        } catch ( Exception $e ) {            throw $e;        }    }    private function isJson( $string ) {        if (is_null($string)) return false;        json_decode($string);        return json_last_error() == JSON_ERROR_NONE;    }    private function toJson( &$data ) {        if ( is_array( $data ) ) {            $data = json_encode( $data );        } elseif ( is_object( $data ) ) {            $data = json_encode( $data );        } elseif ( isJson( $data ) ) {        } else {            $data = json_encode( $data );            //$data = json_encode( array('status'=>'Failed','msg'=>"I can not respond with this data: $data") );            //$status = 406;        }        return $data;    }    private function toArray( &$data ) {        if ( is_array( $data ) ) {        } elseif ( is_object( $data ) ) {            $data = ( array ) $data;        } elseif ( $this->isJson( $data ) ) {            $data = json_decode( $data, true );        } else {            $data = array( $data );        }        return $data;    }    /**     * Like vsprintf, but accepts $args keys instead of order index.     * Both numeric and strings matching /[a-zA-Z0-9_-]+/ are allowed.     *     * Example: vskprintf('y = %y$d, x = %x$1.1f', array('x' => 1, 'y' => 2))     * Result:  'y = 2, x = 1.0'     *     * $args also can be object, then it's properties are retrieved     * using get_object_vars().     *     * '%s' without argument name works fine too. Everything vsprintf() can do     * is supported.     */    public function vksprintf( $str, $args ) {        if ( is_object( $args ) ) {            $args = get_object_vars( $args );        }        $map = array_flip( array_keys( $args ) );        $new_str = preg_replace_callback( '/(^|[^%])%([a-zA-Z0-9_-]+)\$/',            function( $m ) use ( $map ) { return $m[ 1 ].'%'.( $map[ $m[ 2 ] ] + 1 ).'$'; },            $str );        return vsprintf( $new_str, $args );    }    public function translate( $msgId, $parms = array( ) ) {        $message = $this->getTranslator( )->translate( $msgId );        $message = $this->vksprintf ( $message, $parms );        return $message;    }    private function addResponseHeaders( ) {        $response = $this->getResponse();        // If you want to vary based on whether this is a collection or an        // individual item in that collection, check if an identifier from        // the route is present/*        if ( $this->params( )->fromRoute( 'id', false ) ) {            // Allow viewing, partial updating, replacement, and deletion            // on individual items            $headers->addHeaderLine('Allow', implode(',', array(                'GET',                'PATCH',                'PUT',                'DELETE',            )));            return $request;        }*/        // Allow only retrieval and creation on collections        $response->getHeaders()->addHeaderLine( 'Allow', implode( ',', array(                'GET', 'POST', 'PUT', 'OPTIONS', 'DELETE'            ) ) );        //$response->getHeaders()->addHeaderLine( 'Access-Control-Allow-Origin', '*' );        $response->getHeaders()->addHeaderLine( 'Access-Control-Allow-Headers', 'Authorization, Origin, X-Requested-With, Content-Type, Accept' );    }    public function getAccessTokenRecord( $token ) {        // Instantiate the AccessTokens Controller in order to be able to get the record        $OauthAccessTokensController = $this->getServiceLocator( )->get( 'OauthAccessTokensController' );        $OauthAccessTokensController->setValidateOAuth( false );        $result = $OauthAccessTokensController->get( $token );        return $result;    }     public function getTokenContact( ) {        // Get the access_token record        $zf2Request = $this->getRequest( );        $headers    = $zf2Request->getHeaders( );        $token = str_replace( 'Bearer ', '', $headers->get( 'Authorization' )->getFieldValue( ) );        $accessToken = $this->getAccessTokenRecord( $token );        // Instantiate the contact controller        $ContactController = $this->getServiceLocator( )->get( 'ContactController' );        $ContactController->setValidateOAuth( false );        // Get the contact with the user_id associated to the Token        $contact = $ContactController->get( $accessToken->getVariable( USERID ) );                return $contact;    }    public function response( $data = '', $status = 200 ) {        //If it is an exception then create an object with appropiate        //information for the response        if ( $data instanceof CommonException) {            $e = new stdClass;            $status = $data->getCode( );            if ( $status <= 0 ) $status = 400;            $e->status = STATUS_FAILED;            $e->msg = $this->translate ( $data->getMessageId( ), $data->getMessageParms( ) );            $e->errorKey = $data->getErrorKey( );            $data = $e;        } elseif ( $data instanceof Exception) {            $e = new stdClass;            $status = $data->getCode();            if ( $status <= 0 ) $status = 400;            $e->status = STATUS_FAILED;            $e->msg = $this->translate ( $data->getMessage( ) );            $data = $e;        }        if ( $status > 500 ) {            $data->msg = '( ErrorCode: ' . $status . ' ) => ' . $data->msg;            $status = 500;        }        $response = $this->getResponse( );        $response->setStatusCode( $status );        $this->addResponseHeaders( );        return new JsonModel( $this->toArray( $data ) );    }    /* ************************** // !END - UTILS *********************** */}?>